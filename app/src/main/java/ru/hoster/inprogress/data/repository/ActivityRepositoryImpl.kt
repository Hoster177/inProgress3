package ru.hoster.inprogress.data.repository

import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import ru.hoster.inprogress.data.ActivityItem
import ru.hoster.inprogress.domain.model.ActivityRepository
import ru.hoster.inprogress.data.local.ActivityDao
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.SetOptions
import kotlinx.coroutines.tasks.await
import javax.inject.Inject
import javax.inject.Singleton
import android.util.Log
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.firstOrNull
import ru.hoster.inprogress.domain.model.AuthService
import java.util.Calendar
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.launch
import ru.hoster.inprogress.data.TimerSession
import ru.hoster.inprogress.data.local.TimerSessionDao
// import ru.hoster.inprogress.data.repository.remote.FirestoreActivityRepository // Assuming this is not used directly now for sync
import ru.hoster.inprogress.di.ApplicationScope
import java.util.Date
import java.text.SimpleDateFormat
import java.util.Locale

@Singleton
class ActivityRepositoryImpl @Inject constructor(
    private val activityDao: ActivityDao,
    private val timerSessionDao: TimerSessionDao, // Keep if repository manages sessions directly
    private val firestore: FirebaseFirestore,
    private val authService: AuthService,
    // private val fireRepo: FirestoreActivityRepository, // Removed if direct sync logic is below
    @ApplicationScope private val appScope: CoroutineScope
) : ActivityRepository {

    init {
        val uid = authService.getCurrentUserId()
        if (!uid.isNullOrBlank()) {
            Log.d("ActivityRepo_Sync", "Initializing Firestore sync for user: $uid")
            firestore.collection("users").document(uid).collection("activities")
                .addSnapshotListener { snapshots, e ->
                    if (e != null) {
                        Log.w("ActivityRepo_Sync", "Firestore listen failed.", e)
                        return@addSnapshotListener
                    }

                    if (snapshots == null) {
                        Log.w("ActivityRepo_Sync", "Firestore snapshots are null.")
                        return@addSnapshotListener
                    }
                    Log.d("ActivityRepo_Sync", "Received ${snapshots.documents.size} remote activities snapshot.")

                    appScope.launch { // Perform DB operations in appScope
                        for (doc in snapshots.documents) {
                            try {
                                val remoteActivity = doc.toObject(ActivityItem::class.java)?.copy(firebaseId = doc.id)
                                if (remoteActivity == null || remoteActivity.firebaseId.isNullOrBlank()) {
                                    Log.w("ActivityRepo_Sync", "Skipping remote activity, could not parse or blank firebaseId. Doc ID: ${doc.id}")
                                    continue
                                }

                                // Ensure userId from doc/auth matches the activity's userId if it's part of ActivityItem
                                // For now, assuming remoteActivity.userId is correctly populated from Firestore doc.
                                // If not, remoteActivity = remoteActivity.copy(userId = uid)

                                val existingLocalItem = activityDao.getByFirebaseId(remoteActivity.firebaseId!!) // Non-null asserted by check above

                                if (existingLocalItem == null) {
                                    Log.i("ActivityRepo_Sync", "Inserting new activity from Firestore: Name='${remoteActivity.name}', FB_ID='${remoteActivity.firebaseId}'")
                                    // Ensure local ID is generated by Room by setting id to 0L
                                    activityDao.insertActivity(remoteActivity.copy(id = 0L))
                                } else {
                                    // Item exists, update it. Preserve existingLocalItem.id
                                    Log.i("ActivityRepo_Sync", "Updating local activity from Firestore: Name='${remoteActivity.name}', Local_ID=${existingLocalItem.id}, FB_ID='${remoteActivity.firebaseId}'")
                                    activityDao.updateActivity(
                                        existingLocalItem.copy( // Use existingLocalItem.id to ensure correct update
                                            name = remoteActivity.name,
                                            // IMPORTANT: totalDurationMillisToday and isActive should ideally be calculated
                                            // locally based on TimerSessions, not just taken from remote,
                                            // unless Firestore is the single source of truth for these.
                                            totalDurationMillisToday = remoteActivity.totalDurationMillisToday,
                                            isActive = remoteActivity.isActive,
                                            colorHex = remoteActivity.colorHex,
                                            createdAt = remoteActivity.createdAt, // Or decide which timestamp to keep
                                            userId = remoteActivity.userId // Should match
                                        )
                                    )
                                }
                            } catch (parseEx: Exception) {
                                Log.e("ActivityRepo_Sync", "Error parsing remote activity from doc ID: ${doc.id}", parseEx)
                            }
                        }
                        Log.d("ActivityRepo_Sync", "Finished processing snapshot.")
                    }
                }
        } else {
            Log.w("ActivityRepo_Sync", "No user ID, Firestore sync not initialized.")
        }
    }

    override suspend fun addActivity(activity: ActivityItem) {
        // This function assumes 'activity' is a NEW item from UI, so its firebaseId should be null/empty.
        // Its 'id' should be 0L for Room to auto-generate.
        if (!activity.firebaseId.isNullOrBlank()) {
            Log.e("ActivityRepo_Add", "CRITICAL: addActivity called with an item that already has firebaseId: '${activity.firebaseId}'. This is for NEW items. Aborting add.")
            // Potentially throw an IllegalArgumentException or handle as an update if that's intended (though 'add' implies new).
            // For now, we prevent the operation that would likely cause a UNIQUE constraint error.
            // You should investigate why a "new" activity has a firebaseId.
            // As a fallback, you could try to fetch by this firebaseId and update, but that changes the semantics of "add".
            val existing = activityDao.getByFirebaseId(activity.firebaseId!!)
            if (existing != null) {
                Log.w("ActivityRepo_Add", "Found existing item by firebaseId '${activity.firebaseId}'. Consider using 'updateActivity'.")
                // To prevent crash, and if an update is acceptable here:
                // updateActivity(existing.copy(name = activity.name, ... other fields from activity ...))
                // return
                throw IllegalStateException("addActivity called for an item that seems to exist with firebaseId: ${activity.firebaseId}")
            } else {
                // firebaseId is present on input 'activity' but not in DB. This is strange.
                // Proceeding might still cause issues if this firebaseId is later generated by Firestore for another item.
                Log.w("ActivityRepo_Add", "addActivity called with firebaseId='${activity.firebaseId}' which is not in DB, but this is unusual for a new item.")
            }
        }

        try {
            // 1. Ensure id is 0L for Room to generate. Ensure userId is set.
            val activityToInsert = activity.copy(
                id = 0L,
                userId = authService.getCurrentUserId() ?: run {
                    Log.e("ActivityRepo_Add", "Cannot add activity: User ID is null.")
                    throw IllegalStateException("User ID is null, cannot save activity.")
                }
                // firebaseId should be null or empty here
            )

            val localId = activityDao.insertActivity(activityToInsert)
            val activityWithLocalId = activityToInsert.copy(id = localId) // Activity now has the Room-generated local ID

            Log.d("ActivityRepo_Add", "Activity inserted locally: ID=$localId, Name='${activityWithLocalId.name}', UserID='${activityWithLocalId.userId}'")

            // 2. Сохраняем в Firestore (userId is now guaranteed to be non-blank)
            // firebaseId will be generated by Firestore.
            // Create a map for Firestore, explicitly excluding local 'id' and ensuring firebaseId is not sent if null.
            val firestoreActivityMap = activityWithLocalId.toFirestoreMap().toMutableMap()
            firestoreActivityMap.remove("id") // Don't store local Room ID in Firestore document field
            // firebaseId in toFirestoreMap() might be null, which is fine; Firestore handles document ID.

            val documentReference = firestore.collection("users")
                .document(activityWithLocalId.userId)
                .collection("activities")
                .add(firestoreActivityMap) // Firestore generates the document ID
                .await()

            val newFirebaseId = documentReference.id // This is the Firestore-generated ID
            Log.d("ActivityRepo_Add", "Activity added to Firestore: FB_ID='$newFirebaseId'")

            // 3. Обновляем локальную запись с firebaseId, полученным от Firestore
            activityDao.updateActivity(activityWithLocalId.copy(firebaseId = newFirebaseId))
            Log.d("ActivityRepo_Add", "Local activity (ID=$localId) updated with FB_ID='$newFirebaseId'")

        } catch (e: Exception) {
            Log.e("ActivityRepo_Add", "Error adding activity: ${e.message}", e)
            if (e.message?.contains("UNIQUE constraint failed") == true) {
                Log.e("ActivityRepo_Add", "UNIQUE constraint failure during addActivity. This likely means the initial 'activity' object had a conflicting firebaseId or the sync logic is racing.")
            }
            throw e
        }
    }
    // ... (rest of your ActivityRepositoryImpl: updateActivity, getActivitiesForTodayFlow, etc.)
    // Make sure toFirestoreMap() doesn't include 'id' if you don't want it in Firestore fields,
    // and correctly handles 'firebaseId' (it should be the document ID, not a field within the document unless you have a specific reason).

    override suspend fun updateActivity(activity: ActivityItem) {
        try {
            // Ensure userId is present
            val userId = activity.userId.takeIf { it.isNotBlank() } ?: authService.getCurrentUserId() ?: run {
                Log.e("ActivityRepo_Update", "Cannot update activity: User ID is null or blank.")
                throw IllegalStateException("User ID is null or blank, cannot update activity.")
            }
            val activityToUpdate = activity.copy(userId = userId)


            activityDao.updateActivity(activityToUpdate)
            Log.d("ActivityRepo_Update", "Activity updated locally: Local_ID=${activityToUpdate.id}, FB_ID='${activityToUpdate.firebaseId}', Name='${activityToUpdate.name}'")

            if (!activityToUpdate.firebaseId.isNullOrBlank()) {
                val firestoreMap = activityToUpdate.toFirestoreMap().toMutableMap()
                firestoreMap.remove("id") // Don't store local Room ID in Firestore field

                firestore.collection("users")
                    .document(userId) // Use consistent userId
                    .collection("activities")
                    .document(activityToUpdate.firebaseId!!) // Non-null asserted
                    .set(firestoreMap, SetOptions.merge())
                    .await()
                Log.d("ActivityRepo_Update", "Activity updated in Firestore: FB_ID='${activityToUpdate.firebaseId}'")
            } else {
                Log.w("ActivityRepo_Update", "FirebaseID is blank for Local_ID=${activityToUpdate.id}, activity not synced to Firestore on update.")
            }
        } catch (e: Exception) {
            Log.e("ActivityRepo_Update", "Error updating activity: ${e.message}", e)
            throw e
        }
    }


    // Helper to convert ActivityItem to a Map for Firestore
    // Ensure this aligns with how ActivityItem is structured and what you want in Firestore
    private fun ActivityItem.toFirestoreMap(): Map<String, Any?> {
        return mapOf(
            // "id" is the local Room ID. Generally, we don't store this as a field in Firestore
            // if firebaseId (document ID) is the canonical identifier in Firestore.
            // "firebaseId" is the Firestore document ID. It's part of the document path,
            // so it doesn't strictly need to be a field *inside* the document unless you want it for queries.
            // For simplicity, let's assume it's NOT a field inside the document for now.
            "userId" to userId,
            "name" to name,
            "totalDurationMillisToday" to totalDurationMillisToday,
            "isActive" to isActive,
            "colorHex" to colorHex,
            "createdAt" to createdAt // Firestore can convert java.util.Date to Timestamp
        )
    }

    override fun getActivitiesForTodayFlow(): Flow<List<ActivityItem>> { // Возвращаем List<ActivityItem>
        val currentUserId = authService.getCurrentUserId()
        if (currentUserId == null) {
            Log.w("ActivityRepo", "getActivitiesForTodayFlow: No current user ID. Returning empty list.")
            return flowOf(emptyList())
        }

        val calendar = Calendar.getInstance()
        val todayStartDate = calendar.apply {
            set(Calendar.HOUR_OF_DAY, 0); set(Calendar.MINUTE, 0); set(Calendar.SECOND, 0); set(Calendar.MILLISECOND, 0)
        }.time
        val todayEndDate = calendar.apply {
            set(Calendar.HOUR_OF_DAY, 23); set(Calendar.MINUTE, 59); set(Calendar.SECOND, 59); set(Calendar.MILLISECOND, 999)
        }.time

        Log.d("ActivityRepo", "getActivitiesForTodayFlow for user '$currentUserId', DateRange: $todayStartDate - $todayEndDate")

        // 1. Получаем базовый Flow активностей пользователя
        val baseActivitiesFlow = activityDao.getActivitiesForUserFlow(currentUserId)
            .map { activities -> // Фильтруем по дате создания, если это все еще актуально
                activities.filter { activity ->
                    activity.createdAt.time >= todayStartDate.time && activity.createdAt.time <= todayEndDate.time
                }
            }

        // 2. Получаем Flow всех сессий пользователя за сегодня
        val todaySessionsFlow = timerSessionDao.getSessionsForDateRangeFlow(currentUserId, todayStartDate, todayEndDate)

        // 3. Комбинируем эти два Flow
        return combine(baseActivitiesFlow, todaySessionsFlow) { activities, allTodaySessions ->
            Log.d("ActivityRepo_Combine", "Combining ${activities.size} activities with ${allTodaySessions.size} total sessions for today.")
            activities.map { activity ->
                // Для каждой активности находим ее сессии из общего списка сессий за сегодня
                val sessionsForThisActivity = allTodaySessions.filter { it.activityId == activity.id }

                val activeSession = sessionsForThisActivity.find { it.endTime == null }
                val isActive = activeSession != null
                val activeSessionStartTimeMillis = activeSession?.startTime?.time

                val completedSessionsDuration = sessionsForThisActivity
                    .filter { it.endTime != null }
                    .sumOf { session ->
                        val duration = (session.endTime?.time ?: 0L) - session.startTime.time
                        if (duration > 0) duration else 0L
                    }

                // totalDurationMillisToday теперь будет суммой завершенных + длительность активной (если есть) до текущего момента
                // Это поле становится менее важным, если ViewModel будет отдельно управлять тикающим таймером.
                // Но для инициализации и для неактивных задач оно полезно.
                var totalDurationToday = completedSessionsDuration
                if (isActive && activeSessionStartTimeMillis != null) {
                    // Длительность активной сессии до "сейчас" (момента обработки в репозитории)
                    totalDurationToday += (System.currentTimeMillis() - activeSessionStartTimeMillis)
                }

                Log.d("ActivityRepo_Enrich", "Enriched Activity: '${activity.name}' (ID ${activity.id}), " +
                        "IsActive: $isActive, CompletedDuration: $completedSessionsDuration, " +
                        "ActiveSessionStart: $activeSessionStartTimeMillis, TotalDurationInRepo: $totalDurationToday")

                // Здесь мы обновляем поля самого ActivityItem.
                // Если ActivityItem неизменяемый, то нужно создавать новый POJO (EnrichedActivityItem).
                // Для простоты предположим, что ActivityItem может быть скопирован с новыми значениями.
                activity.copy(
                    isActive = isActive,
                    // Это поле будет базой для ViewModel. ViewModel добавит к нему тикающую часть.
                    totalDurationMillisToday = completedSessionsDuration,
                    // Дополнительные поля, если вы их добавили в ActivityItem:
                    // totalDurationOfCompletedSessionsMillis = completedSessionsDuration,
                    // activeSessionStartTimeMillis = activeSessionStartTimeMillis

                    // Если в ActivityItem нет таких полей, то totalDurationMillisToday
                    // должно быть суммой завершенных сессий, а isActive и activeSessionStartTimeMillis
                    // используются ViewModel для управления тикающим таймером.
                    // Давайте остановимся на том, что totalDurationMillisToday = completedSessionsDuration
                    // А isActive и activeSessionStartTimeMillis будут использоваться ViewModel.
                    // Это более чистый подход.
                )
            }
        }
            .onEach { enrichedActivities ->
                Log.i("ActivityRepo_Final", "getActivitiesForTodayFlow: Emitting ${enrichedActivities.size} enriched activities.")
            }
    }


    override suspend fun getActivityById(activityIdString: String): ActivityItem? {
        // activityIdString can be either a local Long ID (as String) or a firebaseId String.
        var activity: ActivityItem? = activityDao.getActivityByFirebaseId(activityIdString)
        if (activity == null) {
            activityIdString.toLongOrNull()?.let { localId ->
                activity = activityDao.getActivityByLocalId(localId)
            }
        }
        Log.d("ActivityRepo", "getActivityById for criteria: '$activityIdString', found: ${activity != null} (Name: ${activity?.name}, LocalID: ${activity?.id}, FbID: ${activity?.firebaseId})")
        return activity
    }

    override suspend fun deleteActivity(activityIdString: String) {
        // activityIdString can be local Long ID (as String) or firebaseId String
        val activityToDelete = getActivityById(activityIdString) // Fetches by either

        if (activityToDelete == null) {
            Log.w("ActivityRepo_Delete", "Activity not found for deletion criteria: '$activityIdString'. Cannot delete.")
            return
        }

        try {
            // Delete from Room using its local primary key for safety
            activityDao.deleteActivity(activityToDelete) // Assumes @Delete takes the object
            Log.d("ActivityRepo_Delete", "Activity deleted locally: Name='${activityToDelete.name}', Local_ID=${activityToDelete.id}")

            // Delete from Firestore if firebaseId exists
            if (!activityToDelete.firebaseId.isNullOrBlank() && activityToDelete.userId.isNotBlank()) {
                firestore.collection("users")
                    .document(activityToDelete.userId)
                    .collection("activities")
                    .document(activityToDelete.firebaseId!!) // Non-null asserted
                    .delete()
                    .await()
                Log.d("ActivityRepo_Delete", "Activity deleted from Firestore: FB_ID='${activityToDelete.firebaseId}'")
            } else {
                Log.w("ActivityRepo_Delete", "Could not delete from Firestore: missing firebaseId or userId for Local_ID=${activityToDelete.id}")
            }
        } catch (e: Exception) {
            Log.e("ActivityRepo_Delete", "Error deleting activity (Local_ID=${activityToDelete.id}, FB_ID='${activityToDelete.firebaseId}'): ${e.message}", e)
            throw e
        }
    }

    // These session methods might conflict with TimerService.
    // If HomeViewModel uses TimerService, these might not be needed here or should be coordinated.
    override suspend fun startSession(activityId: Long) {
        val user = authService.getCurrentUserId() ?: return
        Log.d("ActivityRepo", "Deprecated startSession called for activityId: $activityId. Use TimerService.")
        // timerSessionDao.insertSession(...) // Potentially remove if TimerService handles all
    }

    override suspend fun stopSession(activityId: Long) {
        val user = authService.getCurrentUserId() ?: return
        Log.d("ActivityRepo", "Deprecated stopSession called for activityId: $activityId. Use TimerService.")
        // timerSessionDao.updateSession(...) // Potentially remove
    }
    override fun getSessionsForDateRange(uid: String, from: Date, to: Date): Flow<List<TimerSession>> {
        return timerSessionDao.getSessionsForDateRangeFlow(uid, from, to)
    }

    override suspend fun getAllActivities(userId: String): List<ActivityItem> {
        return activityDao.getAllActivitiesList(userId)
    }

    private fun formatLogDate(date: Date): String {
        val sdf = SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS Z", Locale.US)
        return sdf.format(date)
    }
}